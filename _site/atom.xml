<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>进击的大黄</title>
  <link href="//atom.xml" rel="self"/>
  <link href=""/>
  <updated>2016-05-12T15:22:33+08:00</updated>
  <id></id>
  <author>
    <name>Huang rp</name>
  </author>

  
  <entry>
    <title>mapreduce及命令声明式编程</title>
    <link href="/2016/05/10/map-reduce-impreative-devlarative/"/>
    <updated>2016-05-10T00:00:00+08:00</updated>
    <id>/2016/05/10/map-reduce-impreative-devlarative</id>
    <content type="html">早晨在看java8的lambda表达式，在java8初体验看到了命令式编程和声明式编程的区别，在文章中的例子中用到了JavaScript数组的map和reduce函数，这两个函数在java和JavaScript的函数式编程中都常用到，就顺便翻了下用通俗易懂的大白话讲解Map/Reduce原理。

map reduce


map（映射）单独对每个元素进行操作，如执行过滤原始数据等；
reduce（化简）如将map操作的元素聚集在一起，获取结果；


命令式和声明式编程


命令式编程：命令机器如何做（how），你想要的（what），都会按你的命令实现。

var a=[1,2,3,4,5...</content>
  </entry>
  
  <entry>
    <title>Java8特性学习</title>
    <link href="/2016/05/10/java8-lambda/"/>
    <updated>2016-05-10T00:00:00+08:00</updated>
    <id>/2016/05/10/java8-lambda</id>
    <content type="html">default方法

在接口内定义一些默认实现，如 java.util.function.Predicate 定义了一个抽象方法用于lambda表达式接口，定义了若干default方法。
比如，在Collection定义了了几个Stream相关的default方法，能保持代码的向下兼容的同时也能加一些新的java8特性。
public interface SimpleInterface {
  public void doSomeWork();

  //A default method in the interface created using &amp;quot;default&amp;quot;...</content>
  </entry>
  
  <entry>
    <title>lambdaexpressions</title>
    <link href="/2016/05/09/java-8-lambda/"/>
    <updated>2016-05-09T00:00:00+08:00</updated>
    <id>/2016/05/09/java-8-lambda</id>
    <content type="html"></content>
  </entry>
  
  <entry>
    <title>linux-expect</title>
    <link href="/2016/04/14/linux-expect/"/>
    <updated>2016-04-14T00:00:00+08:00</updated>
    <id>/2016/04/14/linux-expect</id>
    <content type="html">题记

在我没有搭建基于jenkins的持续集成平台时，项目都是我手动的打包，然后scp到linux服务器，再重启服务。期间，要重复的输入ssh的密码，我就想有没有一种简单的方式，能写一个脚本来一键进行这些操作。

语法：

#!/usr/bin/expect 告诉操作系统脚本代码使用哪一种shell执行
set timeout 300 设置超时时间，比如ssh时等待出现密码输入界面时间
spawn ssh root@192.168.1.100 spawn进入expect环境后，创建一个expect管理的与其他程序或者远程设备交互的session，用来传递交互指令。
expect &amp;qu...</content>
  </entry>
  
  <entry>
    <title>python基础语法学习记录笔记</title>
    <link href="/2016/01/11/python-learning/"/>
    <updated>2016-01-11T00:00:00+08:00</updated>
    <id>/2016/01/11/python-learning</id>
    <content type="html">第一天-基础语法

注释后面空一格，逗号后面空一格，函数前面空两行，行后面的注释要空两格，语句里面的= &amp;gt; &amp;lt;左右都要空一格
#!/usr/bin/env python
# coding=utf-8
# 设置文件字符集编码,不设置使用中文会报错
print &amp;quot;hello world&amp;quot;
# input and output
name = raw_input(&amp;#39;name:&amp;#39;)  # waiting user input
print name, &amp;#39;is who&amp;#39;  # str concat

# escape with \
pri...</content>
  </entry>
  
  <entry>
    <title>写在开始</title>
    <link href="/2015/05/14/blog-init/"/>
    <updated>2015-05-14T00:00:00+08:00</updated>
    <id>/2015/05/14/blog-init</id>
    <content type="html">初衷

之前看到javahen的博客挺不错的，简洁、清晰，但是一直没深入研究一下,我过去使用了一年的博客，从购买服务器、域名、备案，到软件环境的搭建以及整个博客代码的编写,都是自己一点点弄的。
代码放倒了github上，博客内容展示部分参考了苏洋的一个个人博客，后台是我自己写的一个cms，用的java+bootstrap+jqueryui，编辑器用的是百度的ueditor，中间缝缝补补了很多小细节。
这一年里，博客伴着我也发生了很多有趣的事情，最开始我给博客对鼻子和王楠开放了权限，他们只写了几篇博客就再也没上过了，我自己前后也写了116篇，从生活到工作。中间我的操作系统从用了多年的win...</content>
  </entry>
  
  <entry>
    <title>多线程-forkjoinpoll</title>
    <link href="/2015/05/11/java-concurrent-forkjoinpool/"/>
    <updated>2015-05-11T00:00:00+08:00</updated>
    <id>/2015/05/11/java-concurrent-forkjoinpool</id>
    <content type="html">首先我们需要先知道并发(Concurrency)和并行(Parallelism)的区别,下面是so上一个作者的回答


Concurrency is when two or more tasks can start, run, and complete in overlapping time periods. It doesn&amp;#39;t necessarily mean they&amp;#39;ll ever both be running at the same instant. Eg. multitasking on a single-core machine.
Parallelism ...</content>
  </entry>
  
  <entry>
    <title>netty源码阅读笔记</title>
    <link href="/2015/05/04/netty-study/"/>
    <updated>2015-05-04T00:00:00+08:00</updated>
    <id>/2015/05/04/netty-study</id>
    <content type="html">AbstractBootstrap构建流程

channelFactory.newChannel()来创建NioServerSocketChannel
//AbstractBootstrap
private ChannelFuture doBind(final SocketAddress localAddress) {
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.ca...</content>
  </entry>
  
</feed>
